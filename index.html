<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaPipe 臉部地標控制煙花</title>
    <!-- 載入 p5.js 函式庫 -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.3/lib/p5.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            user-select: none;
            font-family: 'Inter', sans-serif;
        }
        canvas { 
            display: block; 
            z-index: 1;
        }
        #video {
            position: absolute;
            opacity: 0; /* 隱藏影片元素，只在 p5.js 中使用其串流 */
        }
    </style>
</head>
<body>
    <video id="video" autoplay playsinline></video>

<script type="module">
// --- MediaPipe 模組導入 (已修正: 使用 import 語法來正確定義類別) ---
import { 
    FilesetResolver, 
    FaceLandmarker 
} from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.js";

// --- MediaPipe 全域變數 ---
let faceLandmarker;
let video;
let lastVideoTime = -1;
let mouthIsDown = false; // 模擬滑鼠按壓狀態

// --- 嘴部偵測閾值 (標準化距離) ---
// 垂直距離 (13 - 14) / 臉部寬度 (10 - 333)
const MOUTH_OPEN_THRESHOLD = 0.08; // 嘴巴張開的閾值 (例如：O形)
const MOUTH_CLOSE_THRESHOLD = 0.03; // 嘴巴閉合的閾值 (例如：_形)

// --- 煙花常數 (與原程式碼相同) ---
const BASE_PARTICLE_COUNT_MAX = 12; 
const BASE_PARTICLE_COUNT_MIN = 4;  
const SYMMETRY = 8;                 
const FIXED_BLOOM_SPEED = 0.5;
const FIXED_BLOOM_RATIO = 0.5;  
const GRADIENT_SEGMENTS = 20; 
const MIN_DURATION = 50;  
const MAX_DURATION = 2000; 
const MIN_SPEED = 0.15; 
const MAX_SPEED = 1.0;  
const WARM_COLORS = [50, 60, 35, 350, 320, 310]; 
const COOL_COLORS = [130, 165, 185, 195, 210, 280]; 
const STYLE_CONFIGS = [
    { useWarm: true, isPale: false, isWhite: false }, 
    { useWarm: false, isPale: true, isWhite: false }, 
    { useWarm: true, isPale: false, isWhite: true },  
    { useWarm: false, isPale: false, isWhite: false },
    { useWarm: true, isPale: true, isWhite: false },  
    { useWarm: false, isPale: false, isWhite: true }, 
];

// --- 煙花全域變數 ---
let baseLoc = [];       
let baseVel = [];       
let fireworks = [];     
let auroraHue = 0;      
let currentStyleIndex = 0; 
let mouseStartTime = 0; // 現在代表嘴巴張開的時間


// --- A. MediaPipe 初始化 ---

/**
 * 初始化 MediaPipe FaceLandmarker
 */
async function createFaceLandmarker() {
    console.log("正在載入 MediaPipe 模型...");
    const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
    );
    
    faceLandmarker = await FaceLandmarker.create(vision, {
        baseOptions: {
            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker_v2_with_blendshapes/float16/1/face_landmarker_v2_with_blendshapes.task`,
            delegate: "GPU"
        },
        runningMode: "VIDEO",
        outputFaceBlendshapes: true,
        numFaces: 1
    });

    console.log("模型載入成功! 正在啟動攝像頭...");
}

/**
 * 啟動攝像頭並將串流設定給 video 元素
 */
function startWebcam() {
    video = document.getElementById('video');
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        // 瀏覽器將在這裡彈出請求攝像頭權限的視窗
        navigator.mediaDevices.getUserMedia({ video: true })
            .then(function(stream) {
                video.srcObject = stream;
                video.addEventListener('loadeddata', () => {
                    console.log("攝像頭就緒! 指示: 張開嘴巴(按壓開始)，閉上嘴巴(按壓結束/發射煙花)。");
                });
            })
            .catch(function(err) {
                console.error("無法取得攝像頭存取權限:", err);
                console.error("攝像頭錯誤: 存取被拒絕或發生其他問題。請檢查權限設定。");
            });
    }
}

/**
 * 計算兩個地標點之間的歐幾里得距離
 */
function getDistance(p1, p2, width, height) {
    // 座標範圍在 [0, 1]，需要乘上實際寬高
    const x1 = p1.x * width;
    const y1 = p1.y * height;
    const x2 = p2.x * width;
    const y2 = p2.y * height;
    return dist(x1, y1, x2, y2);
}

/**
 * 嘴部動作偵測和煙花觸發的核心邏輯
 */
function detectMouthAction() {
    if (!faceLandmarker || !video || video.readyState !== 4) return;

    // 只有當有新的影片幀時才進行偵測
    const now = performance.now();
    if (lastVideoTime !== video.currentTime) {
        lastVideoTime = video.currentTime;
        const results = faceLandmarker.detectForVideo(video, now);

        if (results.faceLandmarks && results.faceLandmarks.length > 0) {
            const landmarks = results.faceLandmarks[0];
            
            // 嘴巴垂直距離 (上唇中心 13, 下唇中心 14)
            const mouthVerticalDist = getDistance(landmarks[13], landmarks[14], width, height);
            
            // 臉部水平寬度 (臉頰 10, 333) - 用作標準化參考
            const faceHorizontalDist = getDistance(landmarks[10], landmarks[333], width, height);

            // 標準化嘴部距離
            const normalizedMouthDist = mouthVerticalDist / faceHorizontalDist;
            
            // 簡化狀態機的 Console 輸出，避免過度刷屏
            let currentAction = '未動作';

            // --- 觸發狀態機 ---
            if (!mouthIsDown) {
                // 狀態 1: 嘴巴閉合 -> 偵測張開 (按壓開始)
                if (normalizedMouthDist > MOUTH_OPEN_THRESHOLD) {
                    mouthIsDown = true;
                    mouseStartTime = millis();
                    currentAction = '按壓開始 (嘴巴張開)';
                }
            } else {
                // 狀態 2: 嘴巴張開 -> 偵測閉合 (釋放並發射煙花)
                if (normalizedMouthDist < MOUTH_CLOSE_THRESHOLD) {
                    
                    const pressDuration = millis() - mouseStartTime;

                    // 觸發煙花發射
                    spawnFirework(pressDuration);
                    
                    // 重置狀態
                    mouthIsDown = false;
                    mouseStartTime = 0;
                    currentAction = `按壓結束 (煙花釋放!) - 持續時間: ${pressDuration.toFixed(0)}ms`;
                }
            }

            // 只在狀態改變時或定期輸出狀態 (為了演示，暫時保留每次輸出)
            // console.log(`標準化嘴部距離: ${normalizedMouthDist.toFixed(3)} | 狀態: ${currentAction}`);
            
        } else {
            // 沒有偵測到臉部
            // console.log('未偵測到臉部...');
        }
    }
}


// --- B. p5.js 初始化與主迴圈 ---

function setup() {
    createCanvas(windowWidth, windowHeight);
    colorMode(HSB, 360, 100, 100, 100); 
    background(0, 0, 0); 
    noFill();
    
    // 載入模型和啟動攝像頭 (使用 IIFE 確保非同步執行)
    (async () => {
        await createFaceLandmarker();
        startWebcam();
    })();

    // 初始化最大數量的基礎粒子位置和速度
    for (let i = 0; i < BASE_PARTICLE_COUNT_MAX; i++) {
      baseLoc[i] = createVector(random(-50, 50), random(-50, 50));
      baseVel[i] = p5.Vector.random2D().mult(random(3, 10));
    }
}

function spawnFirework(pressDuration) {
    if (pressDuration <= 0) return;

    // 1. 速度控制 (與pressDuration成反比)
    const fireworkSpeedFactor = map(pressDuration, MIN_DURATION, MAX_DURATION, MAX_SPEED, MIN_SPEED, true);
    
    // 2. 密度控制 (與pressDuration成反比)
    const fireworkParticleCount = floor(map(
        pressDuration, 
        MIN_DURATION, MAX_DURATION, 
        BASE_PARTICLE_COUNT_MAX, BASE_PARTICLE_COUNT_MIN, 
        true
    ));

    // 發射位置：簡單地設在畫布中心下方，避免與臉部偵測重疊
    const launchX = width / 2;
    const launchY = height * 0.75; 

    // 創建 Firework，傳遞速度因子和動態粒子數量
    fireworks.push(new Firework(launchX, launchY, currentStyleIndex, fireworkSpeedFactor, fireworkParticleCount));
    
    // 循環風格索引
    currentStyleIndex = (currentStyleIndex + 1) % STYLE_CONFIGS.length;
}

function draw() {
    // 執行 MediaPipe 偵測邏輯
    detectMouthAction();

    // 根據當前模擬的速度因子計算動態的背景淡出透明度
    let currentSpeedFactor = (fireworks.length > 0) ? fireworks[fireworks.length - 1].speedFactor : MAX_SPEED;
    const dynamicFadeAlpha = map(currentSpeedFactor, MIN_SPEED, MAX_SPEED, 8, 30);
    
    // 使用動態低透明度黑色背景，實現拖尾軌跡效果
    background(0, 0, 0, dynamicFadeAlpha); 

    auroraHue = (auroraHue + 0.5) % 360;

    for (let i = fireworks.length - 1; i >= 0; i--) {
        const isFinished = fireworks[i].updateAndDisplay(auroraHue);
        
        if (isFinished) {
            fireworks.splice(i, 1);
        }
    }
}

// 視窗尺寸改變時調整畫布大小
function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    background(0, 0, 0); 
}


// --- C. 煙花類別 (與原程式碼相同) ---

class Firework {
    constructor(x, y, styleIndex, speedFactor, particleCount) {
        this.center = createVector(x, y);
        this.waves = [];
        this.isSpawning = true; 
        
        this.config = STYLE_CONFIGS[styleIndex]; 
        this.speedFactor = speedFactor; 
        this.particleCount = particleCount; 
        
        this.spawnWaves(); 
    }
    
    spawnWaves() {
        if (!this.isSpawning) return;

        const { useWarm, isPale, isWhite } = this.config;
        
        let colorPool;
        let numWaves;

        if (isWhite) {
            colorPool = WARM_COLORS; 
            numWaves = 1;
        } else {
            colorPool = useWarm ? WARM_COLORS : COOL_COLORS;
            numWaves = floor(random(3, 5)); 
            numWaves = min(numWaves, colorPool.length); 
        }

        let selectedHues = [];
        let availableHues = [...colorPool];

        for (let i = 0; i < numWaves; i++) {
            const index = floor(random(availableHues.length));
            const baseHue = availableHues.splice(index, 1)[0]; 
            selectedHues.push(baseHue);
        }

        for (const baseHue of selectedHues) {
            let hueVariation = sin(auroraHue * 0.1) * 10 + cos(auroraHue * 0.15) * 6;
            let hue = (baseHue + hueVariation) % 360;
            if (hue < 0) hue += 360;

            this.waves.push(new Wave(
                hue, 
                FIXED_BLOOM_RATIO, 
                FIXED_BLOOM_SPEED, 
                isPale, 
                isWhite,
                useWarm,
                this.speedFactor, 
                this.particleCount
            ));
        }
        
        this.isSpawning = false;
    }
    
    updateAndDisplay(auroraHue) {
        push();
        translate(this.center.x, this.center.y);

        const maxRadius = max(width, height) * 0.75 * 1.5; 
        for (let i = this.waves.length - 1; i >= 0; i--) {
            this.waves[i].updateAndDisplay(auroraHue, this.speedFactor);
            
            if (this.waves[i].radius > maxRadius) {
                this.waves.splice(i, 1);
            }
        }
        
        pop(); 

        return !this.isSpawning && this.waves.length === 0;
    }
}

class Wave {
    constructor(col, mouseRatio, mouseSpeed, isPale, isWhite, useWarm, speedFactor, particleCount) { 
        this.radius = 0;
        this.color = col; 
        this.positions = [];
        this.velocities = [];
        this.angleOffset = random(TWO_PI);
        this.initialMouseRatio = mouseRatio; 
        this.lineLengthMultiplier = map(mouseSpeed, 0, 1, 2, 6); 
        this.initialStrokeVariation = random(0.5, 1.5); 
        this.isPale = isPale;   
        this.isWhite = isWhite; 
        this.useWarmColor = useWarm; 
        this.speedMultiplier = map(mouseSpeed, 0, 1, 1.0, 2.5); 
        this.particleCount = particleCount; 
        this.speedFactor = speedFactor;

        // NEW: 計算動態摩擦力/衰減係數 (嘴巴張開/閉合時間控制)
        this.friction = map(speedFactor, MIN_SPEED, MAX_SPEED, 0.99, 0.95, true); 
        
        for (let i = 0; i < this.particleCount; i++) {
            this.positions[i] = baseLoc[i].copy(); 
            let baseVelMag = random(3, 10); 
            this.velocities[i] = p5.Vector.random2D().mult(baseVelMag * this.speedMultiplier * this.speedFactor);
        }
    }

    updateAndDisplay(auroraHue, speedFactor) {
        this.radius += (10 + FIXED_BLOOM_SPEED * 20) * speedFactor; 
        const edge = max(width, height) * 0.75; 

        for (let i = 0; i < this.particleCount; i++) {
            let prev = this.positions[i].copy();
            let d = this.positions[i].mag(); 
            
            let noiseFactor = noise(
                this.radius * 0.005, 
                i * 0.1,             
                frameCount * 0.01    
            );
            
            let speedBoostFactor = map(noiseFactor, 0, 1, 0.9, 1.1); 
            
            this.velocities[i].mult(speedBoostFactor * this.friction); 
            this.velocities[i].rotate(random(-0.02, 0.02) * speedFactor);

            this.positions[i].add(this.velocities[i]);

            let newD = this.positions[i].mag();
            
            if (newD > edge) {
                this.positions[i] = createVector(9999, 9999); 
                continue;
            }

            if (d < this.radius) {
                
                let baseSaturation;
                let minSat, maxSat;

                if (this.isWhite) {
                    baseSaturation = map(d, 0, edge, 5, 0); 
                    minSat = 0;
                    maxSat = 5; 
                } else if (this.isPale) {
                    baseSaturation = map(d, 0, edge, 40, 10); 
                    minSat = 10; 
                    maxSat = 55;
                } else { 
                    baseSaturation = map(d, 0, edge, 90, 30);
                    minSat = 30; 
                    maxSat = 100;
                }
                
                let saturationVariation = sin(frameCount * 0.04 + i * 0.1) * 10;
                let saturation = constrain(baseSaturation + saturationVariation, minSat, maxSat);


                for (let n = 0; n < SYMMETRY; n++) {
                    push();
                    rotate((TWO_PI / SYMMETRY) * n + this.angleOffset);

                    let lineDir = p5.Vector.sub(this.positions[i], prev);
                    if (lineDir.mag() > 0) {
                        
                        let dynamicLengthMultiplier = map(FIXED_BLOOM_SPEED, 0, 1, 1.5, 5);
                        let effectiveSpeedMultiplier = lerp(this.lineLengthMultiplier, dynamicLengthMultiplier, 0.2); 
                        let distanceLengthFactor = map(d, 0, edge, 1.0, 2.5); 
                        
                        let combinedScaleFactor = effectiveSpeedMultiplier * distanceLengthFactor; 
                        
                        let lengthNoise = noise(i * 0.2, n * 0.1, frameCount * 0.02);
                        let lengthVariationFactor = map(lengthNoise, 0, 1, 0.5, 1.5); 
                        
                        let lengthScaleFactor = combinedScaleFactor * lengthVariationFactor; 

                        let lineDirNormalized = lineDir.copy().normalize();
                        let originalLength = lineDir.mag();
                        
                        let extensionLength = originalLength * (lengthScaleFactor - 1) * speedFactor * 2; 
                        let extendedEnd = p5.Vector.add(this.positions[i], lineDirNormalized.mult(extensionLength));
                        
                        let startHue = this.color;
                        let endHue = this.color; 

                        if (endHue < 0) endHue += 360;
                        endHue = (endHue + sin(frameCount * 0.02 + i * 0.1) * 20) % 360;
                        if (endHue < 0) endHue += 360;
                        
                        let isBright = ((n % 2 === 0) !== (i % 2 === 0));
                        let baseStrokeWeight = map(d, 0, edge, 0.2, 4.0); 
                        let symmetryStrokeVariation = sin((TWO_PI / SYMMETRY) * n) * 1.8; 
                        let positionStrokeVariation = sin(i * 0.15 + frameCount * 0.03) * 1.5; 
                        let speedStrokeBoost = map(FIXED_BLOOM_SPEED, 0, 1, 0, 2.0); 
                        let timeStrokeVariation = sin(frameCount * 0.05 + n * 0.5) * 1.2; 
                        let particleThicknessNoise = noise(i * 0.05, frameCount * 0.01) * 2.5;

                        let strokeW = baseStrokeWeight + symmetryStrokeVariation + positionStrokeVariation + speedStrokeBoost + timeStrokeVariation + particleThicknessNoise;
                        strokeW = constrain(strokeW, 0.5, 5);
                        
                        let strokeBrightness = this.isWhite ? 100 : (isBright ? 90 : 70); 
                        if (this.isPale && !this.isWhite) strokeBrightness = map(saturation, minSat, maxSat, 60, 95); 
                        
                        let strokeHue = startHue; 
                        if (this.isWhite) strokeHue = 0; 

                        // 顏色漸變處理
                        for (let j = 0; j < GRADIENT_SEGMENTS; j++) {
                            let tStart = j / GRADIENT_SEGMENTS;
                            let tEnd = (j + 1) / GRADIENT_SEGMENTS;
                            
                            let p1 = p5.Vector.lerp(this.positions[i], extendedEnd, tStart);
                            let p2 = p5.Vector.lerp(this.positions[i], extendedEnd, tEnd);
                            
                            let alpha = map(p1.dist(this.positions[i]), 0, this.positions[i].dist(extendedEnd), 100, 0);
                            let alphaNoise = noise(p1.x * 0.005, p1.y * 0.005, frameCount * 0.01);
                            alpha = constrain(alpha * map(alphaNoise, 0, 1, 0.5, 1.5), 0, 100);

                            stroke(strokeHue, saturation, strokeBrightness, alpha);
                            strokeWeight(strokeW);
                            line(p1.x, p1.y, p2.x, p2.y);
                        }
                    }
                    pop();
                }
            }
        }
    }
}
</script>
</body>
</html>
